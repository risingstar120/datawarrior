/* * Copyright 2017 Idorsia Pharmaceuticals Ltd., Hegenheimermattweg 91, CH-4123 Allschwil, Switzerland * * This file is part of DataWarrior. *  * DataWarrior is free software: you can redistribute it and/or modify it under the terms of the * GNU General Public License as published by the Free Software Foundation, either version 3 of * the License, or (at your option) any later version. *  * DataWarrior is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * See the GNU General Public License for more details. * You should have received a copy of the GNU General Public License along with DataWarrior. * If not, see http://www.gnu.org/licenses/. * * @author Thomas Sander */package com.actelion.research.datawarrior.task.chem;import com.actelion.research.gui.hidpi.HiDPIHelper;import info.clearthought.layout.TableLayout;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.io.BufferedWriter;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStreamWriter;import java.util.Iterator;import java.util.Map;import java.util.Properties;import java.util.TreeMap;import javax.swing.JButton;import javax.swing.JComboBox;import javax.swing.JComponent;import javax.swing.JLabel;import javax.swing.JPanel;import javax.swing.JRadioButton;import com.actelion.research.chem.Canonizer;import com.actelion.research.chem.Molecule;import com.actelion.research.chem.ScaffoldHelper;import com.actelion.research.chem.StereoMolecule;import com.actelion.research.datawarrior.DEFrame;import com.actelion.research.datawarrior.task.ConfigurableTask;import com.actelion.research.datawarrior.task.file.JFilePathLabel;import com.actelion.research.gui.FileHelper;import com.actelion.research.table.model.CompoundTableModel;/** * Title:        DETaskAnalyseRings.java * Description:  Analyses substituents of given core fragment * Copyright:    Copyright (c) 2004-2013 * Company:      Actelion Ltd. * @author       Thomas Sander * @version 1.0 */public class DETaskAnalyseScaffolds extends ConfigurableTask implements ActionListener {	private static final String[] TYPE_TEXT =				{ "Plain ring systems",				  "Ring systems with substitution pattern",				  "Ring systems with carbon/hetero subst. pattern",				  "Ring system with atomic-no subst. pattern",				  "Murcko scaffold",				  "Murcko skeleton",				  "Most central ring system" };	private static final String[] TYPE_CODE = { "plainRings", "ringsPattern", "ringsClasses", "ringsAtomicNos", "murckoScaffold", "murckoSkeleton", "mostCentralRingSyetem" };	public static final String TASK_NAME = "Analyse Scaffolds";    private static final String PROPERTY_STRUCTURE_COLUMN = "structureColumn";    private static final String PROPERTY_SCAFFOLD_TYPE = "scaffoldType";	private static final String PROPERTY_FILENAME = "fileName";	private static final int TYPE_PLAIN_RINGS = 0;	private static final int TYPE_SUBSTITION_PATTERN = 1;	private static final int TYPE_SUBSTITUENT_CLASSES = 2;//	private static final int TYPE_SUBSTITUENT_1ST_ATOMS = 3;	private static final int TYPE_MURCKO_SCAFFOLD = 4;	private static final int TYPE_MURCKO_SKELETON = 5;	private static final int TYPE_MOST_CENTRAL_RING_SYSTEM = 6;	private CompoundTableModel	mTableModel;    private JComboBox			mComboBoxStructureColumn,mComboBoxOption;	private JButton				mButtonEdit;    private JFilePathLabel		mLabelFileName;    private JRadioButton		mRadioButtonSaveFrequencies;    private boolean				mCheckOverwrite;    public DETaskAnalyseScaffolds(DEFrame parent) {    	super(parent, true);		mTableModel = parent.getTableModel();		mCheckOverwrite = true;	    }	@Override	public JComponent createDialogContent() {    	int gap = HiDPIHelper.scale(8);		double[][] size = { {gap, TableLayout.PREFERRED, gap, TableLayout.PREFERRED, TableLayout.FILL, TableLayout.PREFERRED, gap},    						{gap, TableLayout.PREFERRED, gap, TableLayout.PREFERRED, 2*gap, TableLayout.PREFERRED, gap/2, TableLayout.PREFERRED, gap/2, TableLayout.PREFERRED, gap} };		JPanel content = new JPanel();		content.setLayout(new TableLayout(size));		int[] idcodeColumn = mTableModel.getSpecialColumnList(CompoundTableModel.cColumnTypeIDCode);		mComboBoxStructureColumn = new JComboBox();		if (idcodeColumn != null)			for (int i=0; i<idcodeColumn.length; i++)				mComboBoxStructureColumn.addItem(mTableModel.getColumnTitle(idcodeColumn[i]));		mComboBoxStructureColumn.setEditable(!isInteractive());		content.add(new JLabel("Structure column:"), "1,1");		content.add(mComboBoxStructureColumn, "3,1");		mComboBoxOption = new JComboBox(TYPE_TEXT);		content.add(new JLabel("Scaffold type:"), "1,3");		content.add(mComboBoxOption, "3,3,5,3");		mRadioButtonSaveFrequencies = new JRadioButton("Save scaffold frequency file");		mRadioButtonSaveFrequencies.addActionListener(this);		content.add(mRadioButtonSaveFrequencies, "1,5,3,5");		mButtonEdit = new JButton(JFilePathLabel.BUTTON_TEXT);		mButtonEdit.addActionListener(this);		content.add(new JLabel("Scaffold frequency file name:"), "1,7,3,7");		content.add(mButtonEdit, "5,7");		mLabelFileName = new JFilePathLabel(!isInteractive());		content.add(mLabelFileName, "1,9,5,9");		return content;		}	@Override	public void actionPerformed(ActionEvent e) {		if (e.getSource() == mRadioButtonSaveFrequencies) {			mButtonEdit.setEnabled(mRadioButtonSaveFrequencies.isSelected());			if (mLabelFileName.getPath() == null) {				File dataFile = mTableModel.getFile();				File dir = FileHelper.getCurrentDirectory();				String dirname = (dir == null) ? "" : dir + File.separator;				String defaultName = (dataFile == null) ? dirname+"scaffoldAnalysis.dwar"							: dataFile.getPath().substring(0, dataFile.getPath().length()-5)+"_scaffoldAnalysis.dwar";				mLabelFileName.setPath(defaultName);				}			return;			}		if (e.getActionCommand().equals(JFilePathLabel.BUTTON_TEXT)) {			String filename = resolvePathVariables(mLabelFileName.getPath());			if (filename == null)				filename = "Scaffold Analysis";			filename = new FileHelper(getParentFrame()).selectFileToSave("Save Ring Frequency File",					FileHelper.cFileTypeDataWarrior, filename);			if (filename != null) {				mLabelFileName.setPath(filename);				mCheckOverwrite = false;				}			return;			}		}	@Override	public Properties getDialogConfiguration() {		Properties configuration = new Properties();		configuration.setProperty(PROPERTY_STRUCTURE_COLUMN, (String)mComboBoxStructureColumn.getSelectedItem());		configuration.setProperty(PROPERTY_SCAFFOLD_TYPE, TYPE_CODE[mComboBoxOption.getSelectedIndex()]);		if (mRadioButtonSaveFrequencies.isSelected())			configuration.setProperty(PROPERTY_FILENAME, mLabelFileName.getPath() == null ? "" : mLabelFileName.getPath());		return configuration;		}	@Override	public void setDialogConfiguration(Properties configuration) {		String structureColumn = configuration.getProperty(PROPERTY_STRUCTURE_COLUMN, "");		if (structureColumn.length() != 0) {			int column = mTableModel.findColumn(structureColumn);			if (column != -1 && mTableModel.isColumnTypeStructure(column))				mComboBoxStructureColumn.setSelectedItem(mTableModel.getColumnTitle(column));			else if (!isInteractive())				mComboBoxStructureColumn.setSelectedItem(structureColumn);			else if (mComboBoxStructureColumn.getItemCount() != 0)				mComboBoxStructureColumn.setSelectedIndex(0);			}		else if (!isInteractive()) {			mComboBoxStructureColumn.setSelectedItem("Structure");			}		mComboBoxOption.setSelectedIndex(findListIndex(configuration.getProperty(PROPERTY_SCAFFOLD_TYPE), TYPE_CODE, 0));		String fileName = configuration.getProperty(PROPERTY_FILENAME);		mRadioButtonSaveFrequencies.setSelected(fileName != null);		mButtonEdit.setEnabled(fileName != null);		mLabelFileName.setPath(fileName);		}	@Override	public void setDialogConfigurationToDefault() {		if (mComboBoxStructureColumn.getItemCount() != 0)			mComboBoxStructureColumn.setSelectedIndex(0);		else if (!isInteractive())			mComboBoxStructureColumn.setSelectedItem("Structure");		mComboBoxOption.setSelectedIndex(0);		mRadioButtonSaveFrequencies.setSelected(false);		mButtonEdit.setEnabled(false);		mLabelFileName.setPath(null);		}	class CountHolder {		private int count = 1;		public int getCount() {			return count;			}		public void incrementCount() {			count++;			}		}	@Override	public boolean isConfigurable() {		int[] idcodeColumn = mTableModel.getSpecialColumnList(CompoundTableModel.cColumnTypeIDCode);		if (idcodeColumn == null) {			showErrorMessage("No column with chemical structures found.");			return false;			}		return true;		}	@Override	public String getTaskName() {		return TASK_NAME;		}	@Override	public String getHelpURL() {		return "/html/help/chemistry.html#ScaffoldAnalysis";		}	@Override	public boolean isConfigurationValid(Properties configuration, boolean isLive) {		String structureColumn = configuration.getProperty(PROPERTY_STRUCTURE_COLUMN, "");		if (structureColumn.length() == 0) {			showErrorMessage("No structure column defined.");			return false;			}		if (isLive) {			int column = mTableModel.findColumn(structureColumn);			if (column == -1) {				showErrorMessage("Structure column '"+structureColumn+"' not found.");				return false;				}			if (!mTableModel.isColumnTypeStructure(column)) {				showErrorMessage("Column '"+structureColumn+"' does not contain chemical structures.");				return false;				}			}		if (isLive) {			String filename = configuration.getProperty(PROPERTY_FILENAME, "");			if (filename.length() != 0) {				if (!isFileAndPathValid(filename, true, mCheckOverwrite)) {					return false;					}				}			}		return true;		}	@Override	public void runTask(Properties configuration) {		int structureColumn = mTableModel.findColumn(configuration.getProperty(PROPERTY_STRUCTURE_COLUMN, ""));		if (structureColumn == -1)			structureColumn = mTableModel.getSpecialColumnList(CompoundTableModel.cColumnTypeIDCode)[0];		int substitutionMode = findListIndex(configuration.getProperty(PROPERTY_SCAFFOLD_TYPE), TYPE_CODE, 0);		startProgress("Analyzing rings...", 0, mTableModel.getTotalRowCount());		TreeMap<String,CountHolder> fragmentMap = new TreeMap<String,CountHolder>();		String[] fragmentIDCodeList = new String[mTableModel.getTotalRowCount()];		StereoMolecule molContainer = new StereoMolecule();		for (int row=0; row<mTableModel.getTotalRowCount(); row++) {			if (threadMustDie())				break;			if ((row % 16) == 15)				updateProgress(row);			StereoMolecule mol = mTableModel.getChemicalStructure(mTableModel.getTotalRecord(row), structureColumn, CompoundTableModel.ATOM_COLOR_MODE_NONE, molContainer);			if (mol != null) {				StereoMolecule[] fragment = (substitutionMode == TYPE_MURCKO_SCAFFOLD										  || substitutionMode == TYPE_MURCKO_SKELETON) ? getMurckoScaffold(mol, substitutionMode)										  : (substitutionMode == TYPE_MOST_CENTRAL_RING_SYSTEM) ? getMostCentralRingSystem(mol)										  : getRingSystems(mol, substitutionMode);				if (fragment != null) {					for (int i=0; i<fragment.length; i++) {						String fragmentIDCode = new Canonizer(fragment[i]).getIDCode();						fragmentIDCodeList[row] = (i == 0) ? fragmentIDCode														   : fragmentIDCodeList[row] + '\n' + fragmentIDCode;							CountHolder count = fragmentMap.get(fragmentIDCode);						if (count == null)							fragmentMap.put(fragmentIDCode, new CountHolder());						else							count.incrementCount();						}					}				}			}		if (!threadMustDie()) {			String[] columnTitle = { "Ring Systems" };			int newColumn = mTableModel.addNewColumns(columnTitle);			startProgress("Extending Table...", 0, mTableModel.getTotalRowCount());			for (int row=0; row<mTableModel.getTotalRowCount(); row++) {				if (threadMustDie())					break;				updateProgress(row+1);				mTableModel.setTotalValueAt(fragmentIDCodeList[row], row, newColumn);				}			mTableModel.setColumnProperty(newColumn,                                          CompoundTableModel.cColumnPropertySpecialType,                                          CompoundTableModel.cColumnTypeIDCode);			mTableModel.finalizeNewColumns(newColumn, this);			}		if (!threadMustDie()) {			String filename = resolvePathVariables(configuration.getProperty(PROPERTY_FILENAME));			if (filename != null) {				try {					BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(filename),"UTF-8"));					writer.write("idcode\tfrequency");					writer.newLine();					Iterator<Map.Entry<String,CountHolder>> iterator = fragmentMap.entrySet().iterator();					while (iterator.hasNext()) {						Map.Entry<String,CountHolder> entry = iterator.next();						writer.write(entry.getKey()+"\t"+entry.getValue().getCount());						writer.newLine();						}					writer.close();					}				catch (IOException ioe) {					showErrorMessage(ioe.toString());					}				}			}		}	private StereoMolecule[] getMurckoScaffold(StereoMolecule mol, int substitutionMode) {		ScaffoldHelper.createMurckoScaffold(mol, substitutionMode == TYPE_MURCKO_SKELETON);		if (mol.getAllAtoms() == 0)			return null;		StereoMolecule[] scaffold = new StereoMolecule[1];		scaffold[0] = mol;		return scaffold;		}	private StereoMolecule[] getMostCentralRingSystem(StereoMolecule mol) {		ScaffoldHelper.createMostCentralRingSystem(mol);		if (mol.getAllAtoms() == 0)			return null;		StereoMolecule[] scaffold = new StereoMolecule[1];		scaffold[0] = mol;		return scaffold;		}	private StereoMolecule[] getRingSystems(StereoMolecule mol, int substitutionMode) {		mol.ensureHelperArrays(Molecule.cHelperRings);		if (mol.getRingSet().getSize() == 0)			return null;		// mark all non-ring atoms for deletion		for (int atom=0; atom<mol.getAtoms(); atom++)			if (!mol.isRingAtom(atom))				mol.setAtomMarker(atom, true);			boolean checkFurther = true;		while (checkFurther) {	// extend ring systems by atoms connected via non-single bonds			checkFurther = false;			for (int bond=0; bond<mol.getBonds(); bond++) {				if (mol.getBondOrder(bond) > 1) {					for (int i=0; i<2; i++) {						int atom1 = mol.getBondAtom(i, bond);						int atom2 = mol.getBondAtom(1-i, bond);						if (mol.isMarkedAtom(atom1)						 && !mol.isMarkedAtom(atom2)) {							mol.setAtomMarker(atom1, false);							checkFurther = true;							}						}					}				}			}		if (substitutionMode != TYPE_PLAIN_RINGS) {			for (int atom=0; atom<mol.getAtoms(); atom++)				if (!mol.isMarkedAtom(atom))					mol.setAtomQueryFeature(atom, Molecule.cAtomQFNoMoreNeighbours, true);				for (int bond=0; bond<mol.getBonds(); bond++) {				for (int i=0; i<2; i++) {					int atom1 = mol.getBondAtom(i, bond);					int atom2 = mol.getBondAtom(1-i, bond);					if ((!mol.isMarkedAtom(atom1) && mol.isMarkedAtom(atom2))					 || (!mol.isMarkedAtom(atom1) && !mol.isMarkedAtom(atom2)					  && !mol.isRingBond(bond)					  && mol.getBondOrder(bond) == 1)) {						if (substitutionMode == TYPE_SUBSTITION_PATTERN) {							mol.setAtomQueryFeature(atom1, Molecule.cAtomQFNoMoreNeighbours, false);							mol.setAtomQueryFeature(atom1, Molecule.cAtomQFMoreNeighbours, true);							}						else {							int newAtom = mol.addAtom(mol.getAtomicNo(atom2));							mol.setAtomQueryFeature(newAtom, Molecule.cAtomQFNoMoreNeighbours, false);							mol.addBond(atom1, newAtom, (i == 0) ? mol.getBondType(bond) : 1);	// retain stereo bond if applicable							if (substitutionMode == TYPE_SUBSTITUENT_CLASSES) {								if (mol.getAtomicNo(newAtom) != 6) {	                                int[] carbonList = new int[1];									carbonList[0] = 6;									mol.setAtomList(newAtom, carbonList, true);									}								}							}						}					}				}			}			if (substitutionMode == TYPE_SUBSTITION_PATTERN) {			for (int atom=0; atom<mol.getAtoms(); atom++) {				if (!mol.isMarkedAtom(atom)				 && (mol.getAtomQueryFeatures(atom) & Molecule.cAtomQFMoreNeighbours) == 0)					mol.setAtomQueryFeature(atom, Molecule.cAtomQFNoMoreNeighbours, true);				}			}			for (int bond=0; bond<mol.getBonds(); bond++) {	// mol.getBonds() doesn't consider added bonds!!!			if (mol.isMarkedAtom(mol.getBondAtom(0, bond))			 || mol.isMarkedAtom(mol.getBondAtom(1, bond))			 || (!mol.isRingBond(bond)			  && mol.getBondOrder(bond) == 1))				mol.setBondType(bond, Molecule.cBondTypeDeleted);			}			for (int atom=0; atom<mol.getAtoms(); atom++)			if (mol.isMarkedAtom(atom))				mol.markAtomForDeletion(atom);			mol.deleteMarkedAtomsAndBonds();			return mol.getFragments();		}	@Override	public DEFrame getNewFrontFrame() {		return null;		}	}