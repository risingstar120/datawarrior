/* * Copyright 2017 Idorsia Pharmaceuticals Ltd., Hegenheimermattweg 91, CH-4123 Allschwil, Switzerland * * This file is part of DataWarrior. *  * DataWarrior is free software: you can redistribute it and/or modify it under the terms of the * GNU General Public License as published by the Free Software Foundation, either version 3 of * the License, or (at your option) any later version. *  * DataWarrior is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * See the GNU General Public License for more details. * You should have received a copy of the GNU General Public License along with DataWarrior. * If not, see http://www.gnu.org/licenses/. * * @author Thomas Sander */package com.actelion.research.datawarrior.task.jep;import org.nfunk.jep.ParseException;import org.nfunk.jep.function.PostfixMathCommand;import java.util.Stack;/** * An Actelion custom function class for JEP * to find the nth occurence of a substring in a text string. * syntax: indexof(String text, String searchText, int n) */public class JEPIndexOfFunction extends PostfixMathCommand {	public JEPIndexOfFunction() {		numberOfParameters = 3;	    }	/**	 * Runs the operation on the inStack. The parameters are popped	 * off the <code>inStack</code>, and the square root of it's value is 	 * pushed back to the top of <code>inStack</code>.	 */	public void run(Stack inStack) throws ParseException {		// check the stack		checkStack(inStack);		// get the parameters from the stack		Object param3 = inStack.pop();		Object param2 = inStack.pop();		Object param1 = inStack.pop();		// check whether the argument is of the right type		if (param1 instanceof String		 && param2 instanceof String		 && param3 instanceof Double) {			String s1 = (String)param1;			String s2 = (String)param2;			int index = -1;			if (s2.length() != 0 && s1.length() >= s2.length()) {				int n = ((Double)param3).intValue()-1;				index = s1.indexOf(s2);				while (index != -1 && n > 0) {					index = s1.indexOf(s2, index+s2.length());					n++;					}				}			// push the result on the inStack			inStack.push(new Double(index == -1 ? -1 : index+1));	// index and n are 1-based		    }		else {			throw new ParseException("Invalid parameter type");		    }	    }    }