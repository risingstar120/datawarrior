/* * Copyright 2017 Idorsia Pharmaceuticals Ltd., Hegenheimermattweg 91, CH-4123 Allschwil, Switzerland * * This file is part of DataWarrior. *  * DataWarrior is free software: you can redistribute it and/or modify it under the terms of the * GNU General Public License as published by the Free Software Foundation, either version 3 of * the License, or (at your option) any later version. *  * DataWarrior is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. * See the GNU General Public License for more details. * You should have received a copy of the GNU General Public License along with DataWarrior. * If not, see http://www.gnu.org/licenses/. * * @author Thomas Sander */package com.actelion.research.datawarrior.task.jep;import org.nfunk.jep.ParseException;import org.nfunk.jep.function.PostfixMathCommand;import java.util.Stack;/** * An Actelion custom function class for JEP * to find the nth occurence of a substring in a text string. * syntax: entry(String text, String delimiter, int n) */public class JEPEntryFunction extends PostfixMathCommand {	public JEPEntryFunction() {		numberOfParameters = 3;	    }	/**	 * Runs the operation on the inStack. The parameters are popped	 * off the <code>inStack</code>, and the square root of it's value is 	 * pushed back to the top of <code>inStack</code>.	 */	public void run(Stack inStack) throws ParseException {		// check the stack		checkStack(inStack);		// get the parameters from the stack		Object param3 = inStack.pop();		Object param2 = inStack.pop();		Object param1 = inStack.pop();		// check whether the argument is of the right type		if (param1 instanceof String		 && param2 instanceof String		 && param3 instanceof Double) {			String s1 = (String)param1;			String s2 = (String)param2;			int n = ((Double)param3).intValue();			String entry = "";			if (n >= 1) {				if (s2.length() == 0) {	// with an empty delimiter we split between every character					if (n<=s1.length())						entry = s1.substring(n-1, n);					}				else {					int index1 = 0;					int index2 = s1.indexOf(s2);					if (n == 1) {						entry = (index2 == -1) ? s1 : s1.substring(0, index2);						}					else {						for (int i=1; index1 != -1 && i<n; i++) {							index1 = (index2 == -1) ? -1 : index2 + s2.length();							index2 = (index2 == -1) ? -1 : s1.indexOf(s2, index1);							}						if (index1 != -1)							entry = (index2 == -1) ? s1.substring(index1) : s1.substring(index1, index2);						}					}				}			// push the result on the inStack			inStack.push(entry);		    }		else {			throw new ParseException("Invalid parameter type");		    }	    }    }